@using Fluxor
@using Moggle.States
@inherits Fluxor.Blazor.Web.Components.FluxorComponent
@inject IDialogService Dialog


<svg viewBox="0 0 @FullWidth @FullHeight" class="moggleSVG">


  <defs>
    <filter id="MyFilter" filterUnits="userSpaceOnUse">

      <!-- offsetBlur -->
      <feGaussianBlur in="SourceAlpha" stdDeviation="4" result="blur"/>
      <feOffset in="blur" dx="4" dy="4" result="offsetBlur"/>

      <!-- litPaint -->
      <feSpecularLighting in="blur" surfaceScale="5" specularConstant=".75"
                          specularExponent="20" lighting-color="#bbbbbb"
                          result="specOut">
        <fePointLight x="-5000" y="-10000" z="20000"/>
      </feSpecularLighting>
      <feComposite in="specOut" in2="SourceAlpha" operator="in" result="specOut"/>
      <feComposite in="SourceGraphic" in2="specOut" operator="arithmetic"
                   k1="0" k2="1" k3="1" k4="0" result="litPaint"/>

      <!-- merge offsetBlur + litPaint -->
      <feMerge>
        <feMergeNode in="offsetBlur"/>
        <feMergeNode in="litPaint"/>
      </feMerge>
    </filter>

  </defs>

  <rect x="0" y="0" width="@FullWidth" height="@FullHeight" fill="@Colors.Shades.White"/>


   @if (State.Value.ChosenPositions.Any())
  {
    <g filter="url(#MyFilter)">
      @for (var i = 0; i < State.Value.ChosenPositions.Count; i++)
      {
        var (x1, y1) = GetLocation(State.Value.ChosenPositions[i], true);
        string d;
        if (i + 1 < State.Value.ChosenPositions.Count)
        {
          var (x2, y2) = GetLocation(State.Value.ChosenPositions[i + 1], true);
          d = $"M {x1},{y1} L {x2},{y2}";
        }
        else
        {
          d = $"M {x1},{y1} L {x1},{y1}";
        }

        <path id="@($"line-{i}")"
              class="line"
              stroke-dasharray="7 10"
              stroke-linecap="round"
              d="@d"/>
      }
    </g>
  }


  @foreach (var coordinate in State.Value.Board.GetAllCoordinates())
  {
    var color = GetColor(coordinate);
    var (cx, cy) = GetLocation(coordinate, true);

    <g class="square"
       style="transform: translate(@(cx)px, @(cy)px);"
       @onclick="@(() => CellClicked(coordinate))">
      <circle
        id="@($"{coordinate}_bigCircle")"
        stroke="@color"
        fill="@Colors.Shades.Black"
        fill-opacity="0.01"
        r="@CircleRadius"
        class="circle">
      </circle>

      <text
        id="@($"{coordinate}_text")"

        dominant-baseline="middle"
        text-anchor="middle"
        stroke="@Colors.Shades.White"
        fill="@Colors.Shades.Black">
        @State.Value.Board.GetLetterAtCoordinate(coordinate).ButtonText

      </text>
    </g>
  }

  @foreach (var (word, coordinate, rotate,_ ) in RecentWordsState.Value.RecentWords)
  {
    var (cx, cy) = GetLocation(coordinate.Rotate(State.Value.Board.MaxCoordinate, -rotate), false);
    var id = $"{word.Text}{coordinate}";
    <text>
      <text filter="url(#MyFilter)"
        fill="@GetColor(word)"
        class="foundWord"
        style="animation-duration: @(word.LingerDuration)ms"
        pointer-events="none"
        id="@id"
        x="@cx"
        y="@cy"
        dominant-baseline="middle"
        text-anchor="middle">
        @word.Text

      </text>
    </text>
  }




</svg>


<MudChip Icon="@Filled.MilitaryTech">@UncheckedWordState.Value.GetScore(State.Value.FoundWords)</MudChip>
<MudChip Icon="@Filled.Notes">@UncheckedWordState.Value.GetNumberOfWords(State.Value.FoundWords)</MudChip>


<MudList>

  @if (CheatState.Value.Revealed)
  {
    @foreach (var w in CheatState.Value.PossibleWords)
    {
      <MudChip Label="true">@w.Display</MudChip>
    }
  }
  else
  {
    @foreach (var w in State.Value.FoundWords)
    {
      var word = w;
      <MudCheckBox
        Disabled="@(IsGameInProgress)"
        CheckedChanged="(bool b) => { Dispatcher.Dispatch(new UnCheckWord(word, b)); }"
        Label=@word.Display
        Checked="@(!UncheckedWordState.Value.UncheckedWords.Contains(word))"/>
    }
  }
</MudList>

@if (CheatState.Value.AllowCheating && !CheatState.Value.Revealed)
{
  <MudButton OnClick="() => Dispatcher.Dispatch(new CheatAction())">Cheat</MudButton>
}


@code {

  [Inject]
  private IState<MoggleState> State { get; set; }

  [Inject]
  private IState<TimeState> TimeState { get; set; }

  [Inject]
  private IState<FoundWordsState> UncheckedWordState { get; set; }

  [Inject]
  private IState<CheatState> CheatState { get; set; }

  [Inject]
  private IState<AnimationState> AnimationState { get; set; }

  [Inject]
  private IState<RecentWordsState> RecentWordsState { get; set; }

  [Inject]
  private IState<GameSettingsState> GameSettingsState { get; set; }

  [Inject]
  public IDispatcher Dispatcher { get; set; }

  [Parameter]
  public StartGameAction? StartGameAction { get; set; }

  /// <inheritdoc />
  protected override void OnParametersSet()
  {
    if (StartGameAction != null)
      Dispatcher.Dispatch(StartGameAction);

    base.OnParametersSet();
  }

  public bool IsGameInProgress => !TimeState.Value.TimeSituation.IsFinished;

  public double CircleRadius => FullWidth / Math.Max(Columns, Rows) * 0.4;
  public double SquareSize => FullWidth / Math.Max(Columns, Rows);

    public const double FullWidth = 360;
    public const double FullHeight = 360;

  public double LineWidth => FullWidth * 0.05;
  public double CircleStrokeWidth => FullWidth * 0.02;

  public int Columns => State.Value.Board.Columns;
  public int Rows => State.Value.Board.Rows;

  public void CellClicked(Coordinate coordinate)
  {
    if (IsGameInProgress)
    {
      var mr = State.Value.TryGetMoveResult(coordinate);
      Dispatcher.Dispatch(new MoveAction(State.Value.Board.UniqueKey, mr, coordinate));
    }
  }

  private string GetColor(AnimationWord animationWord)
  {
    return animationWord.Type switch
    {
      AnimationWord.WordType.Found           => Colors.Green.Default,
      AnimationWord.WordType.PreviouslyFound => Colors.Blue.Default,
      AnimationWord.WordType.Invalid         => Colors.Red.Default,
      AnimationWord.WordType.Illegal => Colors.Orange.Default,
      _                                      => throw new ArgumentOutOfRangeException()
      };
  }

  public Coordinate GetRotated(Coordinate coordinate) => coordinate.Rotate(
    State.Value.Board.MaxCoordinate,
    RecentWordsState.Value.Rotation * -1);

  public (double x, double y) GetLocation(Coordinate coordinate, bool rotate)
  {
    var rotated = rotate ? GetRotated(coordinate) : coordinate;

    var cx = rotated.Column * SquareSize
             + SquareSize * 0.5;

    var cy = rotated.Row * SquareSize
             + SquareSize * 0.5;
    return (cx, cy);
  }

  public string GetColor(Coordinate coordinate)
  {
    if (!IsGameInProgress || !State.Value.ChosenPositions.Any())
      return Colors.Grey.Default;

    var result = State.Value.TryGetMoveResult(coordinate);

    var color = result switch
    {
      MoveResult.IllegalMove   => Colors.Grey.Default,
      MoveResult.InvalidWord   => Colors.Grey.Darken1,
      MoveResult.MoveRetraced  => Colors.Green.Lighten3,
      MoveResult.WordAbandoned => Colors.Orange.Default,
      MoveResult.WordComplete  => Colors.Green.Darken2,
      MoveResult.WordContinued => Colors.Green.Default,
      _                        => throw new ArgumentOutOfRangeException(nameof(result))
      };

    return color;
  }

  //const string animationTiming = "cubic-bezier(0, 1.06, 0.16, 0.461)";
    const string animationTiming = "ease-out";
}

<style>

  .moggleSVG {
    font-family: monospace;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
    cursor: default;
    font-size: @(144 / Math.Max(Columns, Rows))px;
    width: 100%;
    font-weight: bold;
  }

  .square { transition: 1s @animationTiming }

  .circle {
    stroke-width: @CircleStrokeWidth;

    transition: 3s cubic-bezier(0, 1.45, 0.72, 1.33)
  }

  .circle:hover { transform: scale(1.2) }

  .line {
    stroke-width: @LineWidth;
    stroke: @Colors.LightBlue.Default;
    transition: 1s @animationTiming;
  }

  .foundWord {
    animation-name: disappearAnimation;
    animation-fill-mode: forwards;
    animation-timing-function: ease-out;
    transform-origin: 40% 40%;
  }


  @@keyframes disappearAnimation {
    0% { opacity: 1; }

    50% {
      opacity: 0.2;
      transform: scale(2, 2);
    }

    100% {
      opacity: 0;
      transform: scale(4, 4) rotate(120deg);
    }
  }


</style>
