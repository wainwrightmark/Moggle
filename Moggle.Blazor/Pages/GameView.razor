@using Fluxor
@using Moggle.Actions
@using Moggle.States
@using System.Collections.Immutable
@using System.Net.Http.Headers
@inherits Fluxor.Blazor.Web.Components.FluxorComponent

<MudContainer MaxWidth="MaxWidth.Small">
  <svg viewBox="0 0 @FullWidth @FullHeight" class="moggleSVG">


    <rect x="0" y="0" width="@FullWidth" height="@FullHeight" fill="@Colors.Shades.White"/>


    @{
      var d = ChosenPositions.Value.GetPathD(Board.Value,
                                             RecentWordsState.Value.Rotation, RecentWordsState.Value.Flip, FullWidth, FullHeight);
    }
    <path
      id="rope"

      style="stroke-width: @LineWidth; stroke: @Colors.LightBlue.Default; -webkit-transition: 1s @AnimationTiming; transition: 1s @AnimationTiming; fill: none;"
      stroke-linejoin="round"
      stroke-linecap="round"
      d="@d"/>


    @foreach (var coordinate in Board.Value.GetAllCoordinates())
    {
      var color = GetColor(coordinate);
      var (cx, cy) = GetLocation(coordinate, true);

      <g class="square"
         style="-webkit-transform: translate(@(cx)px, @(cy)px); transform: translate(@(cx)px, @(cy)px);"


         @onclick="@((ca) => CellClicked(coordinate, ca))">
        <circle
          id="@($"{coordinate}_bigCircle")"

          stroke="@color"
          fill="@Colors.Shades.Black"
          fill-opacity="0.01"
          r="@CircleRadius"
          class="circle">
        </circle>

        <text
          id="@($"{coordinate}_text")"

          dominant-baseline="middle"
          text-anchor="middle"
          stroke="@Colors.Shades.White"
          fill="@Colors.Shades.Black">
          @Board.Value.GetLetterAtCoordinate(coordinate).ButtonText

        </text>
      </g>
    }

    @foreach (var (word, coordinate, rotate, flip,_ ) in RecentWordsState.Value.RecentWords)
    {
      var (cx, cy) = GetLocation(coordinate.RotateAndFlip(Board.Value.MaxCoordinate, -rotate, RecentWordsState.Value.Flip), false);
      var id = $"{word.Text}{coordinate}";
      <text>
        <text
          fill="@GetColor(word)"
          class="foundWord"
          style="animation-duration: @(word.LingerDuration)ms"
          pointer-events="none"
          id="@id"
          x="@cx"
          y="@cy"
          dominant-baseline="middle"
          text-anchor="middle">
          @word.Text

        </text>
      </text>
    }




  </svg>
</MudContainer>

<MudContainer MaxWidth="MaxWidth.Small">
  <ResultsView></ResultsView>
</MudContainer>


@code {

  [Inject]
  private IState<MoggleBoard> Board { get; set; }

  [Inject]
  private IState<ChosenPositionsState> ChosenPositions { get; set; }

  [Inject]
  private IState<Solver> Solver { get; set; }

  [Inject]
  private IState<TimeState> TimeState { get; set; }

  [Inject]
  private IState<FoundWordsState> FoundWordsState { get; set; }

  [Inject]
  private IState<CheatState> CheatState { get; set; }

  [Inject]
  private IState<AnimationState> AnimationState { get; set; }

  [Inject]
  private IState<RecentWordsState> RecentWordsState { get; set; }

  [Inject]
  private IState<GameSettingsState> GameSettingsState { get; set; }

  [Inject]
  public IDispatcher Dispatcher { get; set; }

  [Parameter]
  public StartGameAction? StartGameAction { get; set; }

  /// <inheritdoc />
  protected override void OnParametersSet()
  {
    if (StartGameAction != null)
      Dispatcher.Dispatch(StartGameAction);

    base.OnParametersSet();
  }

  public bool IsGameInProgress => !TimeState.Value.TimeSituation.IsFinished;

  public double CircleRadius => FullWidth / Math.Max(Columns, Rows) * 0.4;
  public double SquareSize => FullWidth / Math.Max(Columns, Rows);

    public const double FullWidth = 360;
    public const double FullHeight = 360;

  public double LineWidth => FullWidth * 0.05;
  public double CircleStrokeWidth => FullWidth * 0.02;

  public int Columns => Board.Value.Columns;
  public int Rows => Board.Value.Rows;

  public void CellClicked(Coordinate coordinate, MouseEventArgs mouseEventArgs)
  {
    if (IsGameInProgress)
    {
      var mr = MoveResult.GetMoveResult(coordinate, ChosenPositions.Value, Board.Value, Solver.Value, FoundWordsState.Value);

      if (mouseEventArgs.Detail > 1) //double click
      {
        if (mr is MoveResult.SuccessResult) { }//Don't do anything special
        else
        {
          mr = new MoveResult.WordAbandoned();
        }
      }

      Dispatcher.Dispatch(new MoveAction(Board.Value.UniqueKey, mr, coordinate));
    }
    else
    {
      Dispatcher.Dispatch(new SetPositionsAction(ImmutableList<Coordinate>.Empty));
    }
  }

  private string GetColor(AnimationWord animationWord)
  {
    return animationWord.Type switch
    {
      AnimationWord.WordType.Found           => Colors.Green.Default,
      AnimationWord.WordType.PreviouslyFound => Colors.Blue.Default,
      AnimationWord.WordType.Invalid         => Colors.Red.Default,
      AnimationWord.WordType.Illegal => Colors.Orange.Default,
      _                                      => throw new ArgumentOutOfRangeException()
      };
  }

  public Coordinate GetRotated(Coordinate coordinate) => coordinate.RotateAndFlip(
    Board.Value.MaxCoordinate,
    RecentWordsState.Value.Rotation * -1, RecentWordsState.Value.Flip);

  public (double x, double y) GetLocation(Coordinate coordinate, bool rotate)
  {
    var rotated = rotate ? GetRotated(coordinate) : coordinate;

    var cx = rotated.Column * SquareSize
             + SquareSize * 0.5;

    var cy = rotated.Row * SquareSize
             + SquareSize * 0.5;
    return (cx, cy);
  }

  public string GetColor(Coordinate coordinate)
  {
    if (!IsGameInProgress || !ChosenPositions.Value.ChosenPositions.Any())
      return Colors.Grey.Default;

    var result = MoveResult.GetMoveResult(coordinate, ChosenPositions.Value, Board.Value, Solver.Value, FoundWordsState.Value);

    var color = result switch
    {
      MoveResult.IllegalMove   => Colors.Grey.Default,
      MoveResult.MoveRetraced  => Colors.Green.Lighten3,
      MoveResult.WordAbandoned => Colors.LightBlue.Default,
      MoveResult.WordComplete  => Colors.Green.Darken2,
      MoveResult.WordContinued => Colors.Green.Default,
      _                        => throw new ArgumentOutOfRangeException(nameof(result))
      };

    return color;
  }

    const string AnimationTiming = "ease-out";

}

<style>

  .moggleSVG {
    font-family: monospace;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
    cursor: default;
    font-size: @(144 / Math.Max(Columns, Rows))px;
    width: 100%;
    font-weight: bold;
  }

  .square {
    -webkit-transition: 1s @AnimationTiming;
    transition: 1s @AnimationTiming;
  }

  .circle {
    stroke-width: @CircleStrokeWidth;

    transition: 3s cubic-bezier(0, 1.45, 0.72, 1.33)
  }

  .circle:hover { transform: scale(1.2) }


  .foundWord {
    -webkit-animation-name: disappearAnimation-webkit;
    animation-name: disappearAnimation;
    animation-fill-mode: forwards;
    animation-timing-function: ease-out;
  }

  @@-webkit-keyframes disappearAnimation-webkit {
    0% { opacity: 1; }

    50% {
      opacity: 0.2;
      -webkit-transform: translateY(50%);
    }

    100% {
      opacity: 0;
      -webkit-transform: translateY(100%);
    }
  }

  @@-webkit-keyframes disappearAnimation {
    0% { opacity: 1; }

    50% {
      opacity: 0.2;
      transform: translateY(50%);
    }

    100% {
      opacity: 0;
      transform: translateY(100%);
    }
  }


</style>
