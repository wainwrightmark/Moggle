@using Fluxor
@using Moggle.States
@inherits Fluxor.Blazor.Web.Components.FluxorComponent
@inject IDialogService Dialog
@inject Blazored.LocalStorage.ILocalStorageService localStorage


<svg viewBox="0 0 @FullWidth @FullHeight" class="moggleSVG">

  <rect x="0" y="0" width="@FullWidth" height="@FullHeight" fill="@Colors.Shades.White"/>


  @if (State.Value.ChosenPositions.Any())
  {
    <g>
      @for (var i = 0; i < State.Value.ChosenPositions.Count; i++)
      {
        var (x1, y1) = GetLocation(State.Value.ChosenPositions[i], true);
        string d;
        if (i + 1 < State.Value.ChosenPositions.Count)
        {
          var (x2, y2) = GetLocation(State.Value.ChosenPositions[i + 1], true);
          d = $"M {x1},{y1} L {x2},{y2}";
        }
        else
        {
          d = $"M {x1},{y1} L {x1},{y1}";
        }

        <path id="@($"line-{i}")"
              class="line"
              d="@d"/>
      }
    </g>
  }


  @foreach (var coordinate in State.Value.Board.GetAllCoordinates())
  {
    var color = GetColor(coordinate);
    var (cx, cy) = GetLocation(coordinate, true);

    <g class="square"
       style="transform: translate(@(cx)px, @(cy)px);"
       @onclick="@(() => CellClicked(coordinate))">
      <circle
        id="@($"{coordinate}_bigCircle")"
        stroke="@color"
        fill="@Colors.Shades.White"
        r="@CircleRadius"
        class="circle">
      </circle>

      <text
        id="@($"{coordinate}_text")"

        dominant-baseline="middle"
        text-anchor="middle"
        fill="@Colors.Shades.Black">
        @State.Value.Board.GetLetterAtCoordinate(coordinate).ButtonText

      </text>
    </g>
  }

  @foreach (var (word, coordinate, rotate,_ ) in RecentWordsState.Value.RecentWords)
  {
    var (cx, cy) = GetLocation(coordinate.Rotate(State.Value.Board.MaxCoordinate, -rotate), false);
    var id = $"{word.Text}{coordinate}";
    <text>
      <text
        fill="@GetColor(word)"
        class="foundWord"
        style="animation-duration: @(word.LingerDuration)ms"
        pointer-events="none"
        id="@id"
        x="@cx"
        y="@cy"
        dominant-baseline="middle"
        text-anchor="middle">
        @word.Text

      </text>
    </text>
  }


</svg>


<MudChip Icon="@Filled.MilitaryTech">@UncheckedWordState.Value.GetScore(State.Value.FoundWords)</MudChip>
<MudChip Icon="@Filled.Notes">@UncheckedWordState.Value.GetNumberOfWords(State.Value.FoundWords)</MudChip>


<MudList>

  @if (CheatState.Value.Revealed)
  {
    @foreach (var w in CheatState.Value.PossibleWords)
    {
      <MudChip Label="true">@w.Display</MudChip>
    }
  }
  else
  {
    @foreach (var w in State.Value.FoundWords)
    {
      var word = w;
      <MudCheckBox
        Disabled="@(IsGameInProgress)"
        CheckedChanged="(bool b) => { Dispatcher.Dispatch(new UnCheckWord(word, b)); }"
        Label=@word.Display
        Checked="@(!UncheckedWordState.Value.UncheckedWords.Contains(word))"/>
    }
  }
</MudList>

@if (CheatState.Value.AllowCheating && !CheatState.Value.Revealed)
{
  <MudButton OnClick="() => Dispatcher.Dispatch(new CheatAction())">Cheat</MudButton>
}


@code {

    [Inject]
    private IState<MoggleState> State { get; set; }

    [Inject]
    private IState<TimeState> TimeState { get; set; }

    [Inject]
    private IState<FoundWordsState> UncheckedWordState { get; set; }

    [Inject]
    private IState<CheatState> CheatState { get; set; }

    [Inject]
    private IState<AnimationState> AnimationState { get; set; }

    [Inject]
    private IState<RecentWordsState> RecentWordsState { get; set; }

    [Inject]
    private IState<GameSettingsState> GameSettingsState { get; set; }

    [Inject]
    public IDispatcher Dispatcher { get; set; }

    [Parameter]
    public StartGameAction? StartGameAction { get; set; }

    /// <inheritdoc />
    protected override void OnParametersSet()
    {
      if (StartGameAction != null)
        Dispatcher.Dispatch(StartGameAction);

      base.OnParametersSet();
    }

    public bool IsGameInProgress => !TimeState.Value.TimeSituation.IsFinished;

    public double CircleRadius => FullWidth / Math.Max(Columns, Rows) * 0.4;
    public double SquareSize => FullWidth / Math.Max(Columns, Rows);

    public const double FullWidth = 360;
    public const double FullHeight = 360;

    public double LineWidth => FullWidth * 0.05;
    public double CircleStrokeWidth => FullWidth * 0.02;

    public int Columns => State.Value.Board.Columns;
    public int Rows => State.Value.Board.Rows;

    public void CellClicked(Coordinate coordinate)
    {
      if(IsGameInProgress)
      {
        var mr = State.Value.TryGetMoveResult(coordinate);
      Dispatcher.Dispatch(new MoveAction(mr, coordinate, GameSettingsState.Value.GameString));
      }
    }

    private string GetColor(AnimationWord animationWord)
    {
      return animationWord.Type switch
      {
        AnimationWord.WordType.Found           => Colors.Green.Default,
        AnimationWord.WordType.PreviouslyFound => Colors.Blue.Default,
        AnimationWord.WordType.Invalid         => Colors.Red.Default,
        AnimationWord.WordType.Illegal => Colors.Orange.Default,
        _                                      => throw new ArgumentOutOfRangeException()
      };
    }

    public Coordinate GetRotated(Coordinate coordinate) => coordinate.Rotate(
      State.Value.Board.MaxCoordinate,
      RecentWordsState.Value.Rotation * -1);

    public (double x, double y) GetLocation(Coordinate coordinate, bool rotate)
    {
      var rotated = rotate ? GetRotated(coordinate) : coordinate;

      var cx = rotated.Column * SquareSize
               + SquareSize * 0.5;

      var cy = rotated.Row * SquareSize
               + SquareSize * 0.5;
      return (cx, cy);
    }

    public string GetColor(Coordinate coordinate)
    {
      if (!IsGameInProgress || !State.Value.ChosenPositions.Any())
        return Colors.Grey.Default;

      var result = State.Value.TryGetMoveResult(coordinate);

      var color = result switch
      {
        MoveResult.IllegalMove   => Colors.Grey.Default,
        MoveResult.InvalidWord   => Colors.Grey.Darken1,
        MoveResult.MoveRetraced  => Colors.Green.Lighten3,
        MoveResult.WordAbandoned => Colors.Orange.Default,
        MoveResult.WordComplete  => Colors.Green.Darken2,
        MoveResult.WordContinued => Colors.Green.Default,
        _                        => throw new ArgumentOutOfRangeException(nameof(result))
      };

      return color;
    }

    //const string animationTiming = "cubic-bezier(0, 1.06, 0.16, 0.461)";
    const string animationTiming = "ease-out";
}

<style>

  .moggleSVG {
    font-family: monospace;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
    cursor: default;
    font-size: @(144 / Math.Max(Columns, Rows))px;
    width: 100%;
    font-weight: bold;
  }

  .square { transition: 1s @animationTiming }

  .circle {
    stroke-width: @CircleStrokeWidth;

    transition: 3s cubic-bezier(0, 1.45, 0.72, 1.33)
  }

  .circle:hover { transform: scale(1.2) }

  .line {
    stroke-width: @LineWidth;
    stroke: @Colors.Green.Default;
    transition: 1s @animationTiming;
  }

  .foundWord {
    animation-name: disappearAnimation;
    animation-fill-mode: forwards;
    animation-timing-function: ease-out;
    transform-origin: 40% 40%;
  }


  @@keyframes disappearAnimation {
    0% { opacity: 1; }

    50% {
      opacity: 0.2;
      transform: scale(2, 2);
    }

    100% {
      opacity: 0;
      transform: scale(4, 4) rotate(120deg);
    }
  }


</style>
