@using Fluxor
@using Moggle.Actions
@using Moggle.States
@inherits Fluxor.Blazor.Web.Components.FluxorComponent
@inject IDialogService Dialog

<MudContainer MaxWidth="MaxWidth.Small">
  <svg viewBox="0 0 @FullWidth @FullHeight" class="moggleSVG">


    <rect x="0" y="0" width="@FullWidth" height="@FullHeight" fill="@Colors.Shades.White"/>


    @{
      var d = ChosenPositions.Value.GetPathD(Board.Value,
                                             RecentWordsState.Value.Rotation, FullWidth, FullHeight);
    }
    <path
      id="rope"

      style="stroke-width: @LineWidth; stroke: @Colors.LightBlue.Default; -webkit-transition: 1s @AnimationTiming; transition: 1s @AnimationTiming; fill: none;"
      stroke-linejoin="round"
      stroke-linecap="round"
      d="@d"/>


    @foreach (var coordinate in Board.Value.GetAllCoordinates())
    {
      var color = GetColor(coordinate);
      var (cx, cy) = GetLocation(coordinate, true);

      <g class="square"
         style="-webkit-transform: translate(@(cx)px, @(cy)px); transform: translate(@(cx)px, @(cy)px);"
         @onclick="@(() => CellClicked(coordinate))">
        <circle
          id="@($"{coordinate}_bigCircle")"
          stroke="@color"
          fill="@Colors.Shades.Black"
          fill-opacity="0.01"
          r="@CircleRadius"
          class="circle">
        </circle>

        <text
          id="@($"{coordinate}_text")"

          dominant-baseline="middle"
          text-anchor="middle"
          stroke="@Colors.Shades.White"
          fill="@Colors.Shades.Black">
          @Board.Value.GetLetterAtCoordinate(coordinate).ButtonText

        </text>
      </g>
    }

    @foreach (var (word, coordinate, rotate,_ ) in RecentWordsState.Value.RecentWords)
    {
      var (cx, cy) = GetLocation(coordinate.Rotate(Board.Value.MaxCoordinate, -rotate), false);
      var id = $"{word.Text}{coordinate}";
      <text>
        <text
          fill="@GetColor(word)"
          class="foundWord"
          style="animation-duration: @(word.LingerDuration)ms"
          pointer-events="none"
          id="@id"
          x="@cx"
          y="@cy"
          dominant-baseline="middle"
          text-anchor="middle">
          @word.Text

        </text>
      </text>
    }




  </svg>
</MudContainer>


@if (FoundWordsState.Value.Data is FoundWordsData.TargetWordsData data)
{
  <MudContainer MaxWidth="MaxWidth.Small">

    <MudTabs>
      @foreach (var group in data.WordsToFind.GroupBy(x => x.Value.group).OrderBy(x => x.Key.Order))
      {
        var groupKey = @group.Key;
        var remainingInGroup = group.Count(x => x.Value.word is null);

        <MudTabPanel @key="@groupKey.Display" Text="@groupKey.Display" BadgeData="@remainingInGroup">

          @foreach (var w in group.OrderBy(x => x.Key))
          {
            var key = $"CheckBox{@w.Key}";
            <MudCheckBox @key="@key"
                          Disabled="true"
                          Label="@w.Key"
                          Checked="@(w.Value.word is not null)"/>
          }

        </MudTabPanel>
      }
    </MudTabs>


  </MudContainer>
}
else if (FoundWordsState.Value.Data is FoundWordsData.OpenSearchData openSearchData)
{
  <MudChip Icon="@Icons.Filled.MilitaryTech">@openSearchData.GetScore()</MudChip>
  <MudChip Icon="@Icons.Filled.Notes">@openSearchData.GetNumberOfWords()</MudChip>

  <MudList>

    @if (CheatState.Value.Revealed)
    {
      @foreach (var w in CheatState.Value.PossibleWords)
      {
        <MudChip Label="true">@w.Display</MudChip>
      }
    }
    else
    {
      @foreach (var w in openSearchData.FoundWordsDictionary)
      {
        <MudCheckBox
          Disabled="@(IsGameInProgress)"
          CheckedChanged="(bool b) => { Dispatcher.Dispatch(new EnableDisableWordAction(w.Key, b)); }"
          Label=@w.Key.Display
          Checked="@(w.Value)"/>
      }
    }
  </MudList>

  @if (CheatState.Value.AllowCheating && !CheatState.Value.Revealed)
  {
    <MudButton OnClick="() => Dispatcher.Dispatch(new CheatAction())">Cheat</MudButton>
  }
}





@code {

  [Inject]
  private IState<MoggleBoard> Board { get; set; }

  [Inject]
  private IState<ChosenPositionsState> ChosenPositions { get; set; }

  [Inject]
  private IState<Solver> Solver { get; set; }

  [Inject]
  private IState<TimeState> TimeState { get; set; }

  [Inject]
  private IState<FoundWordsState> FoundWordsState { get; set; }

  [Inject]
  private IState<CheatState> CheatState { get; set; }

  [Inject]
  private IState<AnimationState> AnimationState { get; set; }

  [Inject]
  private IState<RecentWordsState> RecentWordsState { get; set; }

  [Inject]
  private IState<GameSettingsState> GameSettingsState { get; set; }

  [Inject]
  public IDispatcher Dispatcher { get; set; }

  [Parameter]
  public StartGameAction? StartGameAction { get; set; }

  /// <inheritdoc />
  protected override void OnParametersSet()
  {
    if (StartGameAction != null)
      Dispatcher.Dispatch(StartGameAction);

    base.OnParametersSet();
  }

  public bool IsGameInProgress => !TimeState.Value.TimeSituation.IsFinished;

  public double CircleRadius => FullWidth / Math.Max(Columns, Rows) * 0.4;
  public double SquareSize => FullWidth / Math.Max(Columns, Rows);

    public const double FullWidth = 360;
    public const double FullHeight = 360;

  public double LineWidth => FullWidth * 0.05;
  public double CircleStrokeWidth => FullWidth * 0.02;

  public int Columns => Board.Value.Columns;
  public int Rows => Board.Value.Rows;

  public void CellClicked(Coordinate coordinate)
  {
    if (IsGameInProgress)
    {
      var mr = MoveResult.TryGetMoveResult(coordinate, ChosenPositions.Value, Board.Value, Solver.Value, FoundWordsState.Value);
      Dispatcher.Dispatch(new MoveAction(Board.Value.UniqueKey, mr, coordinate));
    }
  }

  private string GetColor(AnimationWord animationWord)
  {
    return animationWord.Type switch
    {
      AnimationWord.WordType.Found           => Colors.Green.Default,
      AnimationWord.WordType.PreviouslyFound => Colors.Blue.Default,
      AnimationWord.WordType.Invalid         => Colors.Red.Default,
      AnimationWord.WordType.Illegal => Colors.Orange.Default,
      _                                      => throw new ArgumentOutOfRangeException()
      };
  }

  public Coordinate GetRotated(Coordinate coordinate) => coordinate.Rotate(
    Board.Value.MaxCoordinate,
    RecentWordsState.Value.Rotation * -1);

  public (double x, double y) GetLocation(Coordinate coordinate, bool rotate)
  {
    var rotated = rotate ? GetRotated(coordinate) : coordinate;

    var cx = rotated.Column * SquareSize
             + SquareSize * 0.5;

    var cy = rotated.Row * SquareSize
             + SquareSize * 0.5;
    return (cx, cy);
  }

  public string GetColor(Coordinate coordinate)
  {
    if (!IsGameInProgress || !ChosenPositions.Value.ChosenPositions.Any())
      return Colors.Grey.Default;

    var result = MoveResult.TryGetMoveResult(coordinate, ChosenPositions.Value, Board.Value, Solver.Value, FoundWordsState.Value);

    var color = result switch
    {
      MoveResult.IllegalMove   => Colors.Grey.Default,
      MoveResult.MoveRetraced  => Colors.Green.Lighten3,
      MoveResult.WordAbandoned => Colors.Orange.Default,
      MoveResult.WordComplete  => Colors.Green.Darken2,
      MoveResult.WordContinued => Colors.Green.Default,
      _                        => throw new ArgumentOutOfRangeException(nameof(result))
      };

    return color;
  }

    const string AnimationTiming = "ease-out";
}

<style>

  .moggleSVG {
    font-family: monospace;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
    cursor: default;
    font-size: @(144 / Math.Max(Columns, Rows))px;
    width: 100%;
    font-weight: bold;
  }

  .square {
    -webkit-transition: 1s @AnimationTiming;
    transition: 1s @AnimationTiming;
  }

  .circle {
    stroke-width: @CircleStrokeWidth;

    transition: 3s cubic-bezier(0, 1.45, 0.72, 1.33)
  }

  .circle:hover { transform: scale(1.2) }


  .foundWord {
    -webkit-animation-name: disappearAnimation-webkit;
    animation-name: disappearAnimation;
    animation-fill-mode: forwards;
    animation-timing-function: ease-out;
  }

  @@-webkit-keyframes disappearAnimation-webkit {
    0% { opacity: 1; }

    50% {
      opacity: 0.2;
      -webkit-transform: translateY(50%);
    }

    100% {
      opacity: 0;
      -webkit-transform: translateY(100%);
    }
  }

  @@-webkit-keyframes disappearAnimation {
    0% { opacity: 1; }

    50% {
      opacity: 0.2;
      transform: translateY(50%);
    }

    100% {
      opacity: 0;
      transform: translateY(100%);
    }
  }


</style>
