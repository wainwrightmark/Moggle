@using Fluxor
@using MoreLinq.Extensions
@inherits Fluxor.Blazor.Web.Components.FluxorComponent
@inject IDialogService Dialog


<svg viewBox="0 0 @FullWidth @FullHeight" class="moggleSVG">

  <rect x="0" y="0" width="@FullWidth" height="@FullHeight" fill="@Colors.Shades.White"/>


  @if (State.Value.ChosenPositions.Any())
  {
    <g>


      @for (var i = 0; i < State.Value.ChosenPositions.Count; i++)
      {
        var co1 = State.Value.ChosenPositions[i];
        var x1 = (co1.Column + 0.5) * SquareSize;
        var y1 = (co1.Row + 0.5) * SquareSize;
        string d;
        if (i + 1 < State.Value.ChosenPositions.Count)
        {
          var co2 = State.Value.ChosenPositions[i + 1];
          var x2 = (co2.Column + 0.5) * SquareSize;
          var y2 = (co2.Row + 0.5) * SquareSize;
          d = $"M {x1},{y1} L {x2},{y2}";
        }
        else
        {
          d = $"M {x1},{y1} L {x1},{y1}";
        }

        <path id="@($"line-{i}")"
              class="line"
              d="@d"/>
      }
    </g>
  }


  @foreach (var coordinate in State.Value.Board.GetAllCoordinates())
  {
    var rotated = coordinate.Rotate(State.Value.Board.MaxCoordinate, -State.Value.Rotation);
    var color = GetColor(rotated);
    var (cx, cy) = GetLocation(rotated);

    <g class="square"
       style="transform: translate(@(cx)px, @(cy)px);"
       @onclick="@(() => CellClicked(rotated))">
      <circle
        id="@($"{coordinate}_bigCircle")"
        stroke="@color"
        fill="@Colors.Shades.White"
        r="@CircleRadius"
        class="circle">
      </circle>

      <text
        id="@($"{coordinate}_text")"

        dominant-baseline="middle"
        text-anchor="middle"
        fill="@Colors.Shades.Black">
        @State.Value.Board.GetLetterAtCoordinate(coordinate).ButtonText

      </text>
    </g>
  }

  @foreach (var (word, coordinate, _) in _recentFoundWords)
  {
      var (cx, cy) = GetLocation(coordinate);
    <text>
      <text
        fill="@Colors.Green.Default"
        class="foundWord"
        pointer-events="none"
        id="score"
        x="@cx"
        y="@cy"
        dominant-baseline="middle"
        text-anchor="middle">
        @word.Display

      </text>
    </text>
  }


</svg>


<MudChip Icon="@Filled.MilitaryTech">@State.Value.Score</MudChip>
<MudChip Icon="@Filled.Notes">@(State.Value.NumberOfWords)</MudChip>


<MudList>

  @if (State.Value.CheatWords != null)
  {
    @foreach (var w in State.Value.CheatWords)
    {
      <MudChip Label="true">@w.Display</MudChip>
    }
  }
  else
  {
    @foreach (var w in State.Value.FoundWords)
    {
      var word = w;
      <MudCheckBox
        Disabled="@(IsGameInProgress)"
        CheckedChanged="(bool b) => { Dispatcher.Dispatch(new EnableWord(word, b)); }"
        Label=@word.Display
        Checked="@(!State.Value.DisabledWords.Contains(word))"/>
    }
  }
</MudList>

@if (State.Value.CheatWords == null && AllowCheating)
{
  <MudButton OnClick="() => Dispatcher.Dispatch(new CheatAction())">Cheat</MudButton>
}


@code {

  [Inject]
  private IState<MoggleState> State { get; set; }

  [Inject]
  public IDispatcher Dispatcher { get; set; }

  public bool AllowCheating => State.Value.LastSettings.ContainsKey("cheat");

  [Parameter]
  public StartGameAction? StartGameAction { get; set; }

  /// <inheritdoc />
  protected override void OnParametersSet()
  {
    if (StartGameAction != null)
      Dispatcher.Dispatch(StartGameAction);

    base.OnParametersSet();
  }

  public bool IsGameInProgress => !State.Value.TimeSituation.IsFinished;

  public string GetColor(Coordinate coordinate)
  {
    if (!IsGameInProgress || !State.Value.ChosenPositions.Any())
      return Colors.Grey.Default;

    var result = State.Value.TryGetMoveResult(coordinate);

    var color = result switch
    {
      MoveResult.IllegalMove   => Colors.Grey.Default,
      MoveResult.InvalidWord   => Colors.Grey.Darken1,
      MoveResult.MoveRetraced  => Colors.Green.Lighten3,
      MoveResult.TimeElapsed   => Colors.Grey.Default,
      MoveResult.WordAbandoned => Colors.Green.Lighten5,
      MoveResult.WordComplete  => Colors.Green.Darken2,
      MoveResult.WordContinued => Colors.Green.Default,
      _                        => throw new ArgumentOutOfRangeException(nameof(result))
      };

    return color;
  }

  public double CircleRadius => FullWidth / Math.Max(Columns, Rows) * 0.325;
  public double SquareSize => FullWidth / Math.Max(Columns, Rows);

    public const double FullWidth = 360;
    public const double FullHeight = 360;

  public double LineWidth => FullWidth * 0.05;
  public double CircleStrokeWidth => FullWidth * 0.02;

  public int Columns => State.Value.Board.Columns;
  public int Rows => State.Value.Board.Rows;

  private List<(FoundWord word, Coordinate coordinate, DateTime expiryDate)> _recentFoundWords = new();

  public void CellClicked(Coordinate coordinate)
  {
    var mr = State.Value.TryGetMoveResult(coordinate);

    Dispatcher.Dispatch(new ChooseCellAction(coordinate));
    UpdateRecentlyFoundWords(mr, coordinate);
  }

  private void UpdateRecentlyFoundWords(MoveResult moveResult, Coordinate coordinate)
  {
    _recentFoundWords.RemoveAll(x => x.expiryDate < DateTime.Now);

    if (moveResult is MoveResult.WordComplete wc)
    {
      _recentFoundWords.Add((wc.FoundWord, coordinate, DateTime.Now.AddMilliseconds(FoundWordDuration)));
    }
  }

  public (double x, double y) GetLocation(Coordinate rotated)
  {
    var cx = rotated.Column * SquareSize
             + SquareSize * 0.5;

    var cy = rotated.Row * SquareSize
             + SquareSize * 0.5;
    return (cx, cy);
  }

      public const int FoundWordDuration = 5000;

}

<style>

  .moggleSVG {
    font-family: monospace;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
    cursor: default;
    font-size: @(144 / Math.Max(Columns, Rows))px;
    width: 100%;
    font-weight: bold;
  }

  .square { transition: 1s cubic-bezier(0, 1.06,0.16,0.461) }

  .circle {
    stroke-width: @CircleStrokeWidth;

    transition: 1s cubic-bezier(0, 1.45,0.72,1.33)
  }

  .circle:hover { transform: scale(1.2) }

  .line {
    stroke-width: @LineWidth;
    stroke: @Colors.Green.Default;
    transition: 1s cubic-bezier(0, 1.06,0.16,0.461);
  }

  .foundWord {
    animation-name: disappearAnimation;
    animation-duration: @(FoundWordDuration)ms;
    animation-fill-mode: forwards;
    animation-timing-function: ease-out;
  }


  @@keyframes disappearAnimation {
    0% { opacity: 1; }

    50% {
      opacity: 0.5;
      transform: scale(2, 2);
    }

    100% {
      opacity: 0;
      transform: scale(4, 4) rotate(360deg);
    }
  }


</style>
