@using Fluxor
@using Moggle.Actions
@using Moggle.States
@inherits Fluxor.Blazor.Web.Components.FluxorComponent
@inject IDialogService Dialog


<svg viewBox="0 0 @FullWidth @FullHeight" class="moggleSVG">


  <defs>
    <filter id="MyFilter" filterUnits="userSpaceOnUse">

      <!-- offsetBlur -->
      <feGaussianBlur in="SourceAlpha" stdDeviation="4" result="blur"/>
      <feOffset in="blur" dx="4" dy="4" result="offsetBlur"/>

      <!-- litPaint -->
      <feSpecularLighting in="blur" surfaceScale="5" specularConstant=".75"
                          specularExponent="20" lighting-color="#bbbbbb"
                          result="specOut">
        <fePointLight x="-5000" y="-10000" z="20000"/>
      </feSpecularLighting>
      <feComposite in="specOut" in2="SourceAlpha" operator="in" result="specOut"/>
      <feComposite in="SourceGraphic" in2="specOut" operator="arithmetic"
                   k1="0" k2="1" k3="1" k4="0" result="litPaint"/>

      <!-- merge offsetBlur + litPaint -->
      <feMerge>
        <feMergeNode in="offsetBlur"/>
        <feMergeNode in="litPaint"/>
      </feMerge>
    </filter>

  </defs>

  <rect x="0" y="0" width="@FullWidth" height="@FullHeight" fill="@Colors.Shades.White"/>


  @{
    var d = ChosenPositions.Value.GetPathD(Board.Value, 
                                           RecentWordsState.Value.Rotation, FullWidth, FullHeight);
  }
  <path
    id="rope"
    filter="url(#MyFilter)"
    style="stroke-width: @LineWidth; stroke: @Colors.LightBlue.Default; transition: 1s @animationTiming; fill: none;"
    stroke-linejoin="round"
    stroke-linecap="round"
    d="@d"/>


  @foreach (var coordinate in Board.Value.GetAllCoordinates())
  {
    var color = GetColor(coordinate);
    var (cx, cy) = GetLocation(coordinate, true);

    <g class="square"
       style="transform: translate(@(cx)px, @(cy)px);"
       @onclick="@(() => CellClicked(coordinate))">
      <circle
        id="@($"{coordinate}_bigCircle")"
        stroke="@color"
        fill="@Colors.Shades.Black"
        fill-opacity="0.01"
        r="@CircleRadius"
        class="circle">
      </circle>

      <text
        id="@($"{coordinate}_text")"

        dominant-baseline="middle"
        text-anchor="middle"
        stroke="@Colors.Shades.White"
        fill="@Colors.Shades.Black">
        @Board.Value.GetLetterAtCoordinate(coordinate).ButtonText

      </text>
    </g>
  }

  @foreach (var (word, coordinate, rotate,_ ) in RecentWordsState.Value.RecentWords)
  {
    var (cx, cy) = GetLocation(coordinate.Rotate(Board.Value.MaxCoordinate, -rotate), false);
    var id = $"{word.Text}{coordinate}";
    <text>
      <text filter="url(#MyFilter)"
            fill="@GetColor(word)"
            class="foundWord"
            style="animation-duration: @(word.LingerDuration)ms"
            pointer-events="none"
            id="@id"
            x="@cx"
            y="@cy"
            dominant-baseline="middle"
            text-anchor="middle">
        @word.Text

      </text>
    </text>
  }




</svg>


<MudChip Icon="@Filled.MilitaryTech">@FoundWordsState.Value.GetScore()</MudChip>
<MudChip Icon="@Filled.Notes">@FoundWordsState.Value.GetNumberOfWords()</MudChip>


<MudList>

  @if (CheatState.Value.Revealed)
  {
    @foreach (var w in CheatState.Value.PossibleWords)
    {
      <MudChip Label="true">@w.Display</MudChip>
    }
  }
  else
  {
    @foreach (var w in FoundWordsState.Value.FoundWords)
    {
      var word = w;
      <MudCheckBox
        Disabled="@(IsGameInProgress)"
        CheckedChanged="(bool b) => { Dispatcher.Dispatch(new UnCheckWord(word, b)); }"
        Label=@word.Display
        Checked="@(!FoundWordsState.Value.UncheckedWords.Contains(word))"/>
    }
  }
</MudList>

@if (CheatState.Value.AllowCheating && !CheatState.Value.Revealed)
{
  <MudButton OnClick="() => Dispatcher.Dispatch(new CheatAction())">Cheat</MudButton>
}


@code {

  [Inject]
  private IState<MoggleBoard> Board { get; set; }

  [Inject]
  private IState<ChosenPositionsState> ChosenPositions { get; set; }

  [Inject]
  private IState<Solver> Solver { get; set; }

  [Inject]
  private IState<TimeState> TimeState { get; set; }

  [Inject]
  private IState<FoundWordsState> FoundWordsState { get; set; }

  [Inject]
  private IState<CheatState> CheatState { get; set; }

  [Inject]
  private IState<AnimationState> AnimationState { get; set; }

  [Inject]
  private IState<RecentWordsState> RecentWordsState { get; set; }

  [Inject]
  private IState<GameSettingsState> GameSettingsState { get; set; }

  [Inject]
  public IDispatcher Dispatcher { get; set; }

  [Parameter]
  public StartGameAction? StartGameAction { get; set; }

  /// <inheritdoc />
  protected override void OnParametersSet()
  {
    if (StartGameAction != null)
      Dispatcher.Dispatch(StartGameAction);

    base.OnParametersSet();
  }

  public bool IsGameInProgress => !TimeState.Value.TimeSituation.IsFinished;

  public double CircleRadius => FullWidth / Math.Max(Columns, Rows) * 0.4;
  public double SquareSize => FullWidth / Math.Max(Columns, Rows);

    public const double FullWidth = 360;
    public const double FullHeight = 360;

  public double LineWidth => FullWidth * 0.05;
  public double CircleStrokeWidth => FullWidth * 0.02;

  public int Columns => Board.Value.Columns;
  public int Rows => Board.Value.Rows;

  public void CellClicked(Coordinate coordinate)
  {
    if (IsGameInProgress)
    {
      var mr = MoveResult.TryGetMoveResult(coordinate, ChosenPositions.Value, Board.Value, Solver.Value, FoundWordsState.Value);
      Dispatcher.Dispatch(new MoveAction(Board.Value.UniqueKey, mr, coordinate));
    }
  }

  private string GetColor(AnimationWord animationWord)
  {
    return animationWord.Type switch
    {
      AnimationWord.WordType.Found           => Colors.Green.Default,
      AnimationWord.WordType.PreviouslyFound => Colors.Blue.Default,
      AnimationWord.WordType.Invalid         => Colors.Red.Default,
      AnimationWord.WordType.Illegal => Colors.Orange.Default,
      _                                      => throw new ArgumentOutOfRangeException()
      };
  }

  public Coordinate GetRotated(Coordinate coordinate) => coordinate.Rotate(
    Board.Value.MaxCoordinate,
    RecentWordsState.Value.Rotation * -1);

  public (double x, double y) GetLocation(Coordinate coordinate, bool rotate)
  {
    var rotated = rotate ? GetRotated(coordinate) : coordinate;

    var cx = rotated.Column * SquareSize
             + SquareSize * 0.5;

    var cy = rotated.Row * SquareSize
             + SquareSize * 0.5;
    return (cx, cy);
  }

  public string GetColor(Coordinate coordinate)
  {
    if (!IsGameInProgress || !ChosenPositions.Value.ChosenPositions.Any())
      return Colors.Grey.Default;

    var result = MoveResult.TryGetMoveResult(coordinate, ChosenPositions.Value, Board.Value, Solver.Value, FoundWordsState.Value);

    var color = result switch
    {
      MoveResult.IllegalMove   => Colors.Grey.Default,
      MoveResult.MoveRetraced  => Colors.Green.Lighten3,
      MoveResult.WordAbandoned => Colors.Orange.Default,
      MoveResult.WordComplete  => Colors.Green.Darken2,
      MoveResult.WordContinued => Colors.Green.Default,
      _                        => throw new ArgumentOutOfRangeException(nameof(result))
      };

    return color;
  }

    const string animationTiming = "ease-out";
}

<style>

  .moggleSVG {
    font-family: monospace;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
    cursor: default;
    font-size: @(144 / Math.Max(Columns, Rows))px;
    width: 100%;
    font-weight: bold;
  }

  .square { transition: 1s @animationTiming }

  .circle {
    stroke-width: @CircleStrokeWidth;

    transition: 3s cubic-bezier(0, 1.45, 0.72, 1.33)
  }

  .circle:hover { transform: scale(1.2) }


  .foundWord {
    animation-name: disappearAnimation;
    animation-fill-mode: forwards;
    animation-timing-function: ease-out;
    transform-origin: 40% 40%;
  }


  @@keyframes disappearAnimation {
    0% { opacity: 1; }

    50% {
      opacity: 0.2;
      transform: scale(2, 2);
    }

    100% {
      opacity: 0;
      transform: scale(4, 4) rotate(120deg);
    }
  }


</style>
